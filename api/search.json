[{"id":"f2b7062f0cb0d9043e818423b0c37216","title":"个人想法","content":"交作业？用了大概一天的时间做出来的 看到Bilbili教学视频一点一点来的\n文章写的很乱，也没什么东西\n以后也会在这里记录一些东西\n简介上有我的B站地址， 平时打代码和游戏的时候会开会直播，同步更新项目的视频。\n如果有大佬看到 希望多多指正，我也会一点点去优化\n","slug":"personal","date":"2999-01-15T10:49:36.000Z","categories_index":"","tags_index":"个人","author_index":"寄许"},{"id":"cd53cdbf97b8f99c953dd3eda45eed25","title":"SpringMVC","content":"SpringMVC介绍\nSpring内置的MVC框架。\n支持RESTful风格的URL请求\n采用了松散耦合可插拔组件结构\n\n原理MVC模式(Model-View-Controller)：解决页面代码和后台代码的分离。\n工作流程SpringMVC的核心组件是dispatcherServlet前端控制器\n这个前端控制器的内部流程为 – 截取url地址，获取到类名和方法名，之后通过Java中的反射机制动态调用某个Controller中的方法，并将方法的返回结果以JSON的数据格式返回给前台。\n\n首先经过dispatcherServlet前端控制器，通过反射动态调用相应的Controller\nController使用@RestController注解，将返回的数据以JSON格式返回给前台\n使用 @RequestMapping（）。填写映射地址，也相当于总路由\n\n常用注解\n@Controller : 表明这是一个Controller\n\n@ResponseBody : 将返回对象写到response的body区，通常用来返回json或xml数据；如果不加responsebody，默认返回的是跳转路径\n\n@RestController : 包含@Controller和@ResponseBody两个注解\n\n@RequestMapping : controller指定可以处理哪些 URL 请求, 具体分为以下几种， 对应RESTful\n\n@PostMapping : Post Request\n@GetMapping : Get Request\n@DeleteMapping : Delete Request\n@PutMapping\n\n\n@PathVariable :  将路径中的参数绑定到请求方法参数上\n\n@RequestBody : 用于将http请求的Body映射绑定到此参数上。只能用于接收对象\n\n@RequestPar : 支持的请求方法是MultipartFile，@RequestPart适用于复杂的请求域（像JSON，XML），既可以接收对象又可以接收二进制数据流\n\n@RequestParam: 只能用来接收基本数据类型、String 或者MultipartFile类型 (绑定请求参数和handler方法形参)\n\n\n","slug":"SpringMVC","date":"2023-02-06T14:05:09.728Z","categories_index":"","tags_index":"Spring笔记","author_index":"寄许"},{"id":"795f915a16128efa588065568418f9f0","title":"Spring框架核心知识点","content":"Spring框架核心知识点简介Spring是一个分层的全栈轻量级开源框架，核心是IOC和AOP，还能整合众多的第三方开源框架和类库。\n优势\n方便解耦，简化开发\nAOP编程的支持\n声明式事务的支持\n方便程序的测试\n方便集成各种优秀框架\n降低JavaEE API的使用难度\n源码是经典的JAVA学习范例\n\n核心结构\n数据处理模块\n\nSpring AOP为数据访问提供了事务管理服务，同时还集成了其他ORM框架\n\n\nWEB模块\n\n该模块提供了SpringMVC框架给WEB应用，WEB层提升了应用的松耦合水平\n\n\nAOP模块 （面向切面编程）\n\nSpring应用系统中开发切面的基础，与DI （依赖注入）一样，AOP可以帮助应用对象解耦。\n\n\n核心容器Core Container模块\n\n管理着Spring应用中bean的创建、配置和管理\nSpringBean工厂 ，实现了Spring 的DI功能\n所有的模块都建立在此之上\n\n\nTest模块\n\n方便进行测试，Spring提供了测试模块来进行Spring应用的测试。\n\n\n\n核心IOC（控制反转） 和 AOP （面向切面编程）\n\nIOC\n\nIOC 技术思想 ，是将原本需要new对象的操作交给IOC容器去完成 ，包括创建实例化对象并管理它，我们需要使用哪个对象，去IOC容器获取即可。反转指对象的创建者反转给IOC容器 \n\n主要解决了对象之间耦合度的问题\n\nIOC 和 DI 的区别\nIOC是站在对象的角度，对象实例化及其管理的权力交给了容器，DI是站在容器的角度，容器会把对象依赖的属性注入。\n\n\n\nAOP\n\nAOP提出横向抽取机制，将横切逻辑代码和业务逻辑代码分离 。减少代码冗余，解耦合\n\n\n\nSpring IOC应用\n基础\n\nbean.xml : 定义需要实例化的类 及各个类之间的依赖关系\nBeanFactory : IOC容器，通过反射达到以上目的\n\n\nBeanFactory和ApplicationContext的区别\n\nBeanFactory是Spring框架IOC容器的顶层接口，用于定义一些基础功能和规范，\nApplicationContext是它的一个子接口。通常我们称BeanFactory是Spring IOC的基础容器，ApplicationContext是容器的高级接口，比BeanFactory拥有更多功能\n\n\nbean标签的常用属性\n\nid ：对象的唯一标识\nclass : 类全名\nname : 类名称\nfactory-bean属性：用于指定创建当前bean对象的⼯⼚⽅法，如配合factory-bean属性使⽤， 则class属性失效。如配合class属性使⽤，则⽅法必须是static的。\nscope：指定bean对象的作用范围，默认是&#96;ingleton\ninit-method属性：指定bean对象的初始化方法，此方法会在bean对象装配后调用，该方法必须是一个无参方法\ndestory-method属性：⽤于指定bean对象的销毁⽅法，此⽅法会在bean对象销毁前执⾏。它只 能为scope是singleton时起作⽤。\n\n\n常用注解\n\n@Autowired ：根据指定类型注入\n@Qualifier : 告诉Spring容器具体去装配那个对象，可以结合@Autowired 唯一确定对象\n@Resource ： 默认按照ByName 自动注入\n@Configuration ：标明当前类为配置类\n@ComponemtScan ： \n@PropertySource ： 引入外部属性配置文件\n@Import ： 引入其他配置类\n@Value : 对变量进行赋值，可以直接赋值。也可以使用${}读取配置文件中的信息\n@Bean ： 将方法返回的对象加入SpringIOC容器中\n\n\n\n代理模式","slug":"Spring","date":"2023-02-06T12:58:21.573Z","categories_index":"","tags_index":"Spring笔记","author_index":"寄许"},{"id":"2f1c2f6b141897e462fbdbeadf23c65d","title":"SpringCache 缓存框架","content":"SpringCache 缓存框架缓存操作的实现，用于提升数据库的访问性能 。但是对于业务来说就可能处理多个缓存。对此提供了SpringCache\n现在业务层提供了缓存的处理支持，所以在数据层不需要进行缓存处理了\n具体就是通过CacheManager接口来同意不同的缓存技术\n\n\n\n\n\n\n提示\n\n注：缓存对象需要实现Serializable接口 序列化才能缓存\n\n\n\n使用Redis\n导入Maven坐标\n\nspring-boot-start-data-redis ，spring-boot-start-cache\n\n\n配置缓存设置 配置application.yml\n1234spring:  cache:  redis:   trime-to-live: 1800000  #设置缓存有效期\n\n常用注解\n@EnableCaching  启动类上，表示开启缓存注解功能\n\n@Cacheable  在方法执行前spring先查看缓存数据，有则返回，没有会将方法的返回值放到缓存中。 一般用于查询\n\n\n1234@Cacheable(value = &quot;userCache&quot;, key = &quot;#id&quot;, condition = &quot;result != null&quot;)  //Spel表达式，动态设置keypublic User getById(Long id) &#123;    userService.getById(id);    return user;\n\n\n\n\n\n\n\n\n特别注意\n\n注意若返回对象为null 依然会进行缓存。需要加condition &#x3D; “result !&#x3D; null” 来限制缓存的条件\n\n123456789@Cacheable(value = &quot;userCache&quot;,key=&quot;#user.id + &#x27;_&#x27; + #user.name&quot;,condition = &quot;result != null&quot;)public List&lt;User&gt; list(User user)&#123;\tLambdaQueryWrapper&lt;User&gt; wrapper = new LamdbaQueryWrapper&lt;&gt;();\t\twrapper.eq(user.getId() != null,User::getId,user.getId());\t\twrapper.eq(user.getName() != null,User::getName,user.getName());\t\tList&lt;User&gt; userList = userService.list(wrapper);\t\treturn userList; &#125;\n\n\n@CachePut 将方法的返回值放到缓存中\n\n一般用于插入数据@CachePut（Value &#x3D; “A”,key &#x3D;”B”）A 表示一类缓存，key表示当前类的缓存的key\n\n\n\n12345@CachePut(value = &quot;userCache&quot;,key=&quot;#user.id&quot;)  //动态获取新增对象id属性`public User save(User user)&#123;\tuserService.save(user);\treturn user;    &#125;\n\n\n\n@CacheEvict 将一条或多条数据从缓存中删除\n\n123456@CacheEvict(value = &quot;userCache&quot;,key=&quot;#id&quot;)  //清除userCache分类下key = id的缓存   public void save(long id)&#123;     userService.removeById(id); \t\treturn user;&#125; @CacheEvict(value = &quot;userCache&quot;,allEntries = true)  // 表示删除当前分类下的所有缓存数据\n\n","slug":"SpringCache","date":"2023-02-06T11:27:01.031Z","categories_index":"","tags_index":"Spring笔记","author_index":"寄许"},{"id":"33b31a83413931658e5fbe1a200a4967","title":"小葡萄点餐（瑞吉）","content":"负责模块管理端管理员登录首先判断该用户是否存在，在判断密码是否正确，最后查看账号状态，若没被禁用即可登录。最后存到session中\n1httpServletRequest.getSession().setAttribute(&quot;employee&quot;, one.getId());\n\n分页12345678910111213141516/** * ClassName：MyBatisPlusConfig * Package:IntelliJ IDEA * MP 分页插件配置 * * @Author:Jixu * @Create:2023/1/29-11:06 */@Configuration // 配置类使用的注解public class MyBatisPlusConfig &#123;    @Bean // 交给spring容器管理    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return mybatisPlusInterceptor;    &#125;\n\n使用MybatisPlus提供的Page对象\n12345678910111213141516171819public class Page&lt;T&gt; imple,ents IPage&lt;T&gt; &#123;\tprotected List&lt;T&gt; records;  // 用来存放查询出来的数据    \tprotected long total; // 返回记录的总数\tprotected long size; //  每页显示条数，默认 10\tprotected long current;  // 当前页,默认1\tprotected List&lt;OrderItem&gt; orders; //  排序字段信息\tprotected boolean optimizeCountSql; // 自动优化 COUNT SQL,默认true\tprotected boolean isSearchCount; //   是否进行 count 查询,默认true\tprotected boolean hitCount; // 是否命中count缓存,默认false&#125;\n\n员工的crud操作均使用MyBatisPlus 实现\n文件的上传与下载\n首先在配置文件里设置文件的存储位置\n\n123little-grape:  path:    D:\\litte-grape\\pictures\\\n\n\n在Controller中定义文件存储路径，使用@Value读取配置文件并赋值\n\n12@Value(&quot;$&#123;little-grape.path&#125;&quot;)String basePath;\n\n\n文件图片的上传\n\n12345678910111213141516171819202122public R&lt;String&gt; upload(MultipartFile file) &#123;    // file为临时文件 ，需要转存到本地磁盘中，否则请求完成后临时文件就会删除    // 获取原始文件名    String originalFilename = file.getOriginalFilename(); // abc.jpg    // 截取后缀 .jpg    String suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));    // 使用uuid重新生成文件名，防止重复    String fileName = UUID.randomUUID().toString() + suffix;    // 创建一个目录对象    File dir = new File(basePath);    // 判断目录是否存在 创建目录    if (!dir.exists()) &#123;        dir.mkdirs();    &#125;    try &#123;        // 降临时文件转存到指定位置        file.transferTo(new File(basePath + fileName));    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;    return R.success(fileName);&#125;\n\n\n文件图片的回显\n\n1234567891011121314151617181920212223242526public void download(String name, HttpServletResponse response) &#123;    try &#123;        // 输入流 ，通过输入流读取文件内容        FileInputStream inputStream = new FileInputStream(new File(basePath + name));        // 输出流，将文件写回游览器，在游览器显示图片        ServletOutputStream servletOutputStream = response.getOutputStream();        // 设置文件格式        response.setContentType(&quot;image/jpeg&quot;);        int length = 0;        byte[] bytes = new byte[1024];        while ((length = inputStream.read(bytes)) != -1) &#123;            servletOutputStream.write(bytes, 0, length);            servletOutputStream.flush();        &#125;        // 关闭资源        inputStream.close();        servletOutputStream.close();    &#125; catch (FileNotFoundException e) &#123;        throw new RuntimeException(e);    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n套餐及菜品修改前先清缓存\n1redisTemplate.delete(key);\n\nStream流 暂时理解为遍历的一种操作  例 ：\n12345List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();flavors = flavors.stream().map((item) -&gt; &#123;  // Stream流表达形式，item为每一项    item.setDishId(dishId); // 赋值    return item; //返回修改后的子对象&#125;).collect(Collectors.toList()); // 转为List集合\n\n自定义业务异常12345public class CustomException extends RuntimeException &#123;    public CustomException(String message)&#123;        super(message);    &#125;&#125;\n\n全局异常处理器12@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;) //所有的异常都能次进行一致处理。@ResponseBody\n\n过滤器使用注解@webFilter , urlPatterns &#x3D; “&#x2F;* 表示拦截所有请求  继承与Filter\n1@WebFilter(filterName = &quot;loginCheckFilter&quot;, urlPatterns = &quot;/*&quot;)\n\n线程项目中使用到线程\n登录过滤器中如果登陆成功调用\nthreadLocal.set(id) 和 threadLocal.get(id)  存储和获取Id\n移动端登录为输入邮箱验证码\n首先导入依赖\n\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n调用提供的 Java 提供的 mailSender对象\n\n1234567891011public void sendMsg(String to, String subject, String context) &#123;    SimpleMailMessage mailMessage = new SimpleMailMessage();    mailMessage.setFrom(from); // 邮件的发送人    mailMessage.setTo(to); // 邮件的接受者邮箱    mailMessage.setSubject(subject); // 邮件的标题    mailMessage.setText(context); // 邮件的具体内容    // 真正的发送邮件操作，从 from到 to    mailSender.send(mailMessage);&#125;\n\nRedis\n在用户第一次进入先查询redis数据库有无菜品及套餐数据 \n（redisTemplate.opsForValue().get(keys);）\n\n\n未查到数据时，在向数据库查询，同时存到redis数据库中 \n（redisTemplate.opsForValue().set(keys, Object, time, TimeUnit.MINUTES);）\n\n\n\n结算点击结算后 创建订单在批量向订单明细添加数据，清空购物车\n","slug":"Little-Grape","date":"2023-02-05T08:39:28.566Z","categories_index":"","tags_index":"项目","author_index":"寄许"},{"id":"7a599eb929e20107b6e749c077b6a900","title":"WeShopping项目","content":"WeShopping项目登录界面动态背景及登录切换卡片\n\n动态背景\n动态背景主要使用&lt;video&gt;标签，score 路径指向本地视频\n视屏屏幕大小用到onresize事件 监听窗口大小变化 \n卡片切换\n卡片切换用到动态绑定样式 .点击按钮v-show实现切换\n商家界面模糊查询动态显示\n\n实时显示搜索结果使用监听器实现\n后台查询模糊查询使用concat函数\n123SELECT *FROM businessWHERE business_name like CONCAT(&#x27;%&#x27;,#&#123;businessName&#125;,&#x27;%&#x27;)\n\n首页显示商品列表及商品详情信息\n\n\n显示商品详情信息主要使用mybatis框架实现\n\n后台接收商品主键 \n封装DTO 包括多对一（商家信息），一对多（商品评论）\n配置xml文件 mapper 标签namespace属性对应dao类全名，select标签id属性对应方法名\n\n1234567891011121314151617181920212223&lt;resultMap type=&quot;io.renren.modules.goobs.dto.GoodsBusinessEvaluationDTO&quot; id=&quot;goodsDtoMap&quot;&gt;  ...    &lt;association property=&quot;businessEntity&quot; javaType=&quot;io.renren.modules.business.entity.BusinessEntity&quot;&gt;      ...    &lt;/association&gt;    &lt;collection property=&quot;evaluationEntities&quot; ofType=&quot;io.renren.modules.evaluation.dto.EvaluationDTO&quot;&gt;     ...    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getBusinessGoodsEvaluationBygoodsId&quot;        resultType=&quot;io.renren.modules.goobs.dto.GoodsBusinessEvaluationDTO&quot; resultMap=&quot;goodsDtoMap&quot;&gt;    SELECT        g.goods_id,g.goods_name,g.category_pid,g.attribute_list,g.goods_description,g.goods_pic,        b.business_id,b.business_name,b.business_address,b.business_tel,b.business_pic,        e.evaluation_id,e.users_id,e.evaluation    FROM        goods g            LEFT JOIN business b                      ON (g.business_id = b.business_id)            LEFT JOIN evaluation e                      ON (g.goods_id=e.goods_id)    WHERE g.goods_id =#&#123;goodsId&#125;&lt;/select&gt;\n\n\n前台根据返回数据进行显示\n\n商城首页\n\n查询购物车即当前用户的配送地址 点击支付创建订单及订单明细，清空购物车\n","slug":"WeShopping","date":"2023-02-05T08:37:39.729Z","categories_index":"","tags_index":"项目","author_index":"寄许"},{"id":"5f849d772fd372114a5b63b97d1479ef","title":"面试题","content":"JDK  JRE  JVMJDK 开发工具包\n提供了编译，运行Java程序的各种工具和资源，包括java编译器，java运行时环境及常用的java类库\nJRE 运行环境\n用于运行java的字节码文件， JRE包括jvm和jvm工作所需的类库\nJVM 虚拟机\njre的一部分 ，是java实现跨平台的关键部分，负责运行字节码文件\nJDK 包含 JRE   ———–JRE包含JVM\nJAVA程序运行原理\n\n源文件(.java)通过编译器编译成字节码文件(.class)\n通过JVM中的解释器将字节码文件生成对应的可执行文件，运行\n将编译后的程序加载到方法区，储存类信息\n运行时，JVM创建线程来执行代码，在虚拟机栈和程序计数器分配独占的空间。根据方法区里的指令码，在虚拟机栈对线程进行操作，程序计数器保存线程代码执行到哪个位置\n\nString StringBuffer StringBuilder 的区别String\nString 对应的是常量。为char[]数组，长度不可变\nStringBuffer\n长度可变，线程安全\nStringBuilder\n长度可变，线程不安全\n&#x3D;&#x3D; 与 equals 的区别&#x3D;&#x3D;\n如果比较的双方为基本数据类型，比较的是值。\n如果比较的双方是引用数据类型是，比较的是引用地址\nequals\n具体看该方法的重写，在String类中，比较的是字符串的各个字符是否相等\nhashCode() 与 equals()hashCode\n可以看作对象的唯一标识\n\nhashcode()方法的作用\nhashcode()方法主要配合基于散列的集合一起使用，比如HashSet、HashMap、HashTable。\n当集合需要添加新的对象时，先调用这个对象的hashcode()方法，得到对应的hashcode值，实际上hashmap中会有一个table保存已经存进去的对象的hashcode值，如果table中没有改hashcode值，则直接存入；如果有，就调用equals方法与新元素进行比较，相同不存，不同就存入。\n\nequals 和 hashcode 的关系\n如果equals为true，hashcode一定相等；\n如果equals为false，hashcode不一定不相等；\n如果hashcode值相等，equals不一定相等；\n如果hashcode值不等，equals一定不等；\n\n重写equals方法时，一定要重写hashcode方法\n\n\n","slug":"text1","date":"2023-02-05T07:20:34.429Z","categories_index":"","tags_index":"面试","author_index":"寄许"},{"id":"e66776905d2645bc37accb6b5de89f2b","title":"Aurora主题的快速使用","content":"快速上手依赖环境12$ Hexo 5.4+$ Yarn or NPM installed\n\n安装指南步骤1 - 安装主题包在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\n1$ npm install hexo-theme-aurora --save\n步骤 2 - 生成主题配置在node_modules文件夹中找到_config.yml 复制到根目录 重命名为_config.aurora.yml\n步骤 3 - 设置 permalink步骤 3.1打开在 Hexo 根目录下的 _config.yml\n步骤 3.2修改 permalink 参数为 &#x2F;post&#x2F;:title.html\n12345678# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://tridiamond.techpermalink: /post/:title.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n\n步骤 4 - 设置代码高亮\n把 highlight 的启用改为false\n把 prismjs 的启用改为true\n把 prismjs 下的 preprocess 改为 false\n\n12345678# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://tridiamond.techpermalink: /post/:title.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n","slug":"hello-world","date":"2023-02-05T03:14:41.431Z","categories_index":"","tags_index":"个人建站","author_index":"寄许"}]